import {
  type ParsedOpenAPISpec,
  type ScaffoldOptions,
  type GeneratedScaffold,
  type GeneratedFile,
  type ToolResponse,
  successResponse,
  errorResponse,
} from '../types.js';
import { generateToolSchemas } from './schemas.js';

/**
 * Generate a complete MCP server scaffold from parsed OpenAPI spec
 */
export function generateServerScaffold(
  parsedSpec: ParsedOpenAPISpec,
  language: 'typescript' | 'python',
  options: ScaffoldOptions = {}
): ToolResponse<GeneratedScaffold> {
  try {
    if (!parsedSpec || typeof parsedSpec !== 'object') {
      return errorResponse('INVALID_INPUT', 'Invalid parsed spec provided', {});
    }

    if (!['typescript', 'python'].includes(language)) {
      return errorResponse('INVALID_INPUT', 'Language must be "typescript" or "python"', {
        provided: language,
      });
    }

    // Get tool schemas first
    const toolSchemasResult = generateToolSchemas(parsedSpec);
    if (!toolSchemasResult.ok) {
      return toolSchemasResult;
    }

    const { tools } = toolSchemasResult.data;

    const serverName = options.server_name || parsedSpec.info.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const serverVersion = options.server_version || parsedSpec.info.version || '1.0.0';
    const author = options.author || 'Generated by openapi-generate';
    const baseUrl = options.base_url || parsedSpec.servers[0]?.url || 'http://localhost:8080';

    let files: GeneratedFile[];

    if (language === 'typescript') {
      files = generateTypeScriptScaffold(parsedSpec, tools, {
        serverName,
        serverVersion,
        author,
        baseUrl,
        includeTests: options.include_tests ?? true,
      });
    } else {
      files = generatePythonScaffold(parsedSpec, tools, {
        serverName,
        serverVersion,
        author,
        baseUrl,
        includeTests: options.include_tests ?? true,
      });
    }

    return successResponse({
      files,
      language,
      tool_count: tools.length,
    });
  } catch (error) {
    return errorResponse('INTERNAL_ERROR', 'Failed to generate server scaffold', {
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

interface ScaffoldConfig {
  serverName: string;
  serverVersion: string;
  author: string;
  baseUrl: string;
  includeTests: boolean;
}

/**
 * Generate TypeScript scaffold files
 */
function generateTypeScriptScaffold(
  spec: ParsedOpenAPISpec,
  tools: { name: string; description: string; inputSchema: object }[],
  config: ScaffoldConfig
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // package.json
  files.push({
    path: 'package.json',
    content: JSON.stringify(
      {
        name: `@dedalus/${config.serverName}`,
        version: config.serverVersion,
        description: spec.info.description || `MCP server for ${spec.info.title}`,
        type: 'module',
        main: 'dist/index.js',
        types: 'dist/index.d.ts',
        bin: {
          [config.serverName]: './dist/index.js',
        },
        scripts: {
          build: 'tsc',
          start: 'node dist/index.js',
          dev: 'tsx src/index.ts',
          test: 'vitest run',
          'test:watch': 'vitest',
          lint: 'eslint src/',
          typecheck: 'tsc --noEmit',
        },
        author: config.author,
        license: 'MIT',
        dependencies: {
          '@modelcontextprotocol/sdk': '^1.0.0',
          express: '^4.21.0',
          zod: '^3.23.8',
        },
        devDependencies: {
          '@types/express': '^4.17.21',
          '@types/node': '^22.10.0',
          tsx: '^4.19.0',
          typescript: '^5.6.0',
          vitest: '^2.1.0',
        },
        engines: {
          node: '>=18.0.0',
        },
      },
      null,
      2
    ),
  });

  // tsconfig.json
  files.push({
    path: 'tsconfig.json',
    content: JSON.stringify(
      {
        compilerOptions: {
          target: 'ES2022',
          module: 'NodeNext',
          moduleResolution: 'NodeNext',
          lib: ['ES2022'],
          outDir: './dist',
          rootDir: './src',
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true,
          declaration: true,
          declarationMap: true,
          sourceMap: true,
          resolveJsonModule: true,
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'dist', 'tests'],
      },
      null,
      2
    ),
  });

  // vitest.config.ts
  files.push({
    path: 'vitest.config.ts',
    content: `import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/**/*.test.ts'],
  },
});
`,
  });

  // src/types.ts
  files.push({
    path: 'src/types.ts',
    content: generateTypesFile(),
  });

  // src/config.ts
  files.push({
    path: 'src/config.ts',
    content: generateConfigFile(config.serverName, config.serverVersion),
  });

  // Generate tool files
  const toolNames: string[] = [];
  for (const tool of tools) {
    const fileName = tool.name.replace(/-/g, '_');
    toolNames.push(fileName);
    files.push({
      path: `src/tools/${fileName}.ts`,
      content: generateToolFile(tool, config.baseUrl),
    });
  }

  // src/tools/index.ts
  files.push({
    path: 'src/tools/index.ts',
    content: generateToolsIndexFile(toolNames),
  });

  // src/transport/stdio.ts
  files.push({
    path: 'src/transport/stdio.ts',
    content: generateStdioTransportFile(),
  });

  // src/transport/http.ts
  files.push({
    path: 'src/transport/http.ts',
    content: generateHttpTransportFile(),
  });

  // src/transport/index.ts
  files.push({
    path: 'src/transport/index.ts',
    content: `export { startStdioTransport } from './stdio.js';
export { startHttpTransport } from './http.js';
`,
  });

  // src/server.ts
  files.push({
    path: 'src/server.ts',
    content: generateServerFile(toolNames, config.serverName, config.serverVersion),
  });

  // src/cli.ts
  files.push({
    path: 'src/cli.ts',
    content: generateCliFile(),
  });

  // src/index.ts (main entry point)
  files.push({
    path: 'src/index.ts',
    content: generateIndexFile(),
  });

  // .env.example
  files.push({
    path: '.env.example',
    content: `# MCP Server Configuration
MCP_TRANSPORT=stdio
MCP_PORT=3000
MCP_HOST=127.0.0.1

# API Configuration
API_BASE_URL=${config.baseUrl}
API_KEY=your-api-key-here
`,
  });

  // .gitignore
  files.push({
    path: '.gitignore',
    content: `node_modules/
dist/
.env
*.log
.DS_Store
coverage/
`,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateReadmeFile(config.serverName, spec.info.description || '', tools.length),
  });

  // Tests
  if (config.includeTests) {
    files.push({
      path: 'tests/unit/tools.test.ts',
      content: generateUnitTestFile(toolNames),
    });

    files.push({
      path: 'tests/e2e/server.test.ts',
      content: generateE2ETestFile(),
    });
  }

  return files;
}

/**
 * Generate Python scaffold files
 */
function generatePythonScaffold(
  spec: ParsedOpenAPISpec,
  tools: { name: string; description: string; inputSchema: object }[],
  config: ScaffoldConfig
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // pyproject.toml
  files.push({
    path: 'pyproject.toml',
    content: `[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "${config.serverName}"
version = "${config.serverVersion}"
description = "${spec.info.description || `MCP server for ${spec.info.title}`}"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
authors = [
    { name = "${config.author}" }
]
dependencies = [
    "mcp>=1.0.0",
    "httpx>=0.27.0",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.23.0",
]

[project.scripts]
${config.serverName} = "${config.serverName.replace(/-/g, '_')}.main:main"

[tool.hatch.build.targets.wheel]
packages = ["src/${config.serverName.replace(/-/g, '_')}"]
`,
  });

  // src/main.py (entry point)
  files.push({
    path: 'src/main.py',
    content: generatePythonMainFile(config.serverName),
  });

  // src/server.py
  files.push({
    path: 'src/server.py',
    content: generatePythonServerFile(tools, config.serverName),
  });

  // src/types.py
  files.push({
    path: 'src/types.py',
    content: generatePythonTypesFile(),
  });

  // src/config.py
  files.push({
    path: 'src/config.py',
    content: generatePythonConfigFile(config.serverName, config.serverVersion, config.baseUrl),
  });

  // src/tools/__init__.py
  const toolNames = tools.map((t) => t.name.replace(/-/g, '_'));
  files.push({
    path: 'src/tools/__init__.py',
    content: toolNames.map((name) => `from .${name} import ${name}`).join('\n') + '\n',
  });

  // Generate tool files
  for (const tool of tools) {
    const fileName = tool.name.replace(/-/g, '_');
    files.push({
      path: `src/tools/${fileName}.py`,
      content: generatePythonToolFile(tool, config.baseUrl),
    });
  }

  // .env.example
  files.push({
    path: '.env.example',
    content: `# MCP Server Configuration
MCP_TRANSPORT=stdio
MCP_PORT=3000
MCP_HOST=127.0.0.1

# API Configuration
API_BASE_URL=${config.baseUrl}
API_KEY=your-api-key-here
`,
  });

  // .gitignore
  files.push({
    path: '.gitignore',
    content: `__pycache__/
*.py[cod]
*$py.class
.env
*.egg-info/
dist/
build/
.pytest_cache/
.coverage
htmlcov/
.venv/
venv/
`,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateReadmeFile(config.serverName, spec.info.description || '', tools.length, 'python'),
  });

  // Tests
  if (config.includeTests) {
    files.push({
      path: 'tests/__init__.py',
      content: '',
    });

    files.push({
      path: 'tests/test_tools.py',
      content: generatePythonTestFile(toolNames),
    });
  }

  return files;
}

// Helper functions to generate file contents

function generateTypesFile(): string {
  return `/**
 * Standard response envelope for all tools
 */
export interface SuccessResponse<T> {
  ok: true;
  data: T;
  meta: ResponseMeta;
}

export interface ErrorResponse {
  ok: false;
  error: {
    code: ErrorCode;
    message: string;
    details: Record<string, unknown>;
  };
  meta: {
    retrieved_at: string;
  };
}

export type ToolResponse<T> = SuccessResponse<T> | ErrorResponse;

export interface ResponseMeta {
  source?: string;
  retrieved_at: string;
  pagination?: {
    next_cursor: string | null;
  };
  warnings: string[];
}

export type ErrorCode =
  | 'INVALID_INPUT'
  | 'UPSTREAM_ERROR'
  | 'RATE_LIMITED'
  | 'TIMEOUT'
  | 'PARSE_ERROR'
  | 'INTERNAL_ERROR';

export interface ServerConfig {
  name: string;
  version: string;
  transport: 'stdio' | 'http';
  port?: number;
  host?: string;
}

/**
 * Helper to create success response
 */
export function successResponse<T>(data: T, meta?: Partial<ResponseMeta>): SuccessResponse<T> {
  return {
    ok: true,
    data,
    meta: {
      retrieved_at: new Date().toISOString(),
      warnings: [],
      ...meta,
    },
  };
}

/**
 * Helper to create error response
 */
export function errorResponse(
  code: ErrorCode,
  message: string,
  details: Record<string, unknown> = {}
): ErrorResponse {
  return {
    ok: false,
    error: {
      code,
      message,
      details,
    },
    meta: {
      retrieved_at: new Date().toISOString(),
    },
  };
}
`;
}

function generateConfigFile(serverName: string, serverVersion: string): string {
  return `import type { ServerConfig } from './types.js';

const DEFAULT_CONFIG: ServerConfig = {
  name: '${serverName}',
  version: '${serverVersion}',
  transport: 'stdio',
  port: 3000,
  host: '127.0.0.1',
};

export function loadConfig(): ServerConfig {
  const transport = (process.env.MCP_TRANSPORT as 'stdio' | 'http') || DEFAULT_CONFIG.transport;

  return {
    name: process.env.MCP_SERVER_NAME || DEFAULT_CONFIG.name,
    version: process.env.MCP_SERVER_VERSION || DEFAULT_CONFIG.version,
    transport,
    port: process.env.MCP_PORT ? parseInt(process.env.MCP_PORT, 10) : DEFAULT_CONFIG.port,
    host: process.env.MCP_HOST || DEFAULT_CONFIG.host,
  };
}

export { DEFAULT_CONFIG };
`;
}

function generateToolFile(
  tool: { name: string; description: string; inputSchema: object },
  baseUrl: string
): string {
  const inputSchema = tool.inputSchema as { properties: Record<string, { type?: string; description?: string }>; required: string[] };
  const params = Object.entries(inputSchema.properties || {});

  const paramTypes = params
    .map(([name, schema]) => {
      const type = schema.type === 'integer' || schema.type === 'number' ? 'number' : schema.type || 'string';
      const tsType = type === 'array' ? 'unknown[]' : type === 'object' ? 'Record<string, unknown>' : type;
      const required = inputSchema.required?.includes(name);
      return `  ${name}${required ? '' : '?'}: ${tsType};`;
    })
    .join('\n');

  return `import { type ToolResponse, successResponse, errorResponse } from '../types.js';

export interface ${toPascalCase(tool.name)}Input {
${paramTypes || '  // No parameters'}
}

export interface ${toPascalCase(tool.name)}Output {
  // Define your output type here
  result: unknown;
}

/**
 * ${tool.description}
 */
export async function ${toCamelCase(tool.name)}(
  input: ${toPascalCase(tool.name)}Input
): Promise<ToolResponse<${toPascalCase(tool.name)}Output>> {
  try {
    // TODO: Implement API call to ${baseUrl}
    // Example:
    // const response = await fetch(\`${baseUrl}/endpoint\`, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(input),
    // });
    // const data = await response.json();

    return successResponse({
      result: input, // Placeholder
    });
  } catch (error) {
    return errorResponse('UPSTREAM_ERROR', 'Failed to execute ${tool.name}', {
      error: error instanceof Error ? error.message : String(error),
    });
  }
}
`;
}

function generateToolsIndexFile(toolNames: string[]): string {
  const imports = toolNames.map((name) => `export { ${toCamelCase(name)} } from './${name}.js';`);
  return imports.join('\n') + '\n';
}

function generateStdioTransportFile(): string {
  return `import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import type { Server } from '@modelcontextprotocol/sdk/server/index.js';

export async function startStdioTransport(server: Server): Promise<void> {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('MCP server running on stdio');
}
`;
}

function generateHttpTransportFile(): string {
  return `import express from 'express';
import type { Server } from '@modelcontextprotocol/sdk/server/index.js';
import type { ServerConfig } from '../types.js';

export async function startHttpTransport(server: Server, config: ServerConfig): Promise<void> {
  const app = express();
  app.use(express.json());

  // Health check endpoint
  app.get('/health', (_req, res) => {
    res.json({ status: 'ok', server: config.name, version: config.version });
  });

  // MCP endpoint would go here
  // Note: HTTP transport for MCP requires SSE or WebSocket implementation

  const port = config.port || 3000;
  const host = config.host || '127.0.0.1';

  app.listen(port, host, () => {
    console.error(\`MCP server running on http://\${host}:\${port}\`);
  });
}
`;
}

function generateServerFile(toolNames: string[], serverName: string, serverVersion: string): string {
  const toolImports = toolNames.map((name) => toCamelCase(name)).join(', ');

  return `import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import { ${toolImports} } from './tools/index.js';

export function createServer(name: string = '${serverName}', version: string = '${serverVersion}'): Server {
  const server = new Server(
    { name, version },
    { capabilities: { tools: {} } }
  );

  // List available tools
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
      tools: [
${toolNames
  .map(
    (name) => `        {
          name: '${name}',
          description: 'Execute ${name}',
          inputSchema: {
            type: 'object',
            properties: {},
            required: [],
          },
        },`
  )
  .join('\n')}
      ],
    };
  });

  // Handle tool calls
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
${toolNames
  .map(
    (toolName) => `      case '${toolName}': {
        const result = await ${toCamelCase(toolName)}(args as Parameters<typeof ${toCamelCase(toolName)}>[0]);
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }`
  )
  .join('\n')}
      default:
        throw new Error(\`Unknown tool: \${name}\`);
    }
  });

  return server;
}
`;
}

function generateCliFile(): string {
  return `export interface CliArgs {
  transport: 'stdio' | 'http';
  port?: number;
  host?: string;
}

export function parseArgs(args: string[]): CliArgs {
  const result: CliArgs = {
    transport: 'stdio',
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--transport' || arg === '-t') {
      const value = args[++i];
      if (value === 'stdio' || value === 'http') {
        result.transport = value;
      }
    } else if (arg === '--port' || arg === '-p') {
      result.port = parseInt(args[++i], 10);
    } else if (arg === '--host' || arg === '-h') {
      result.host = args[++i];
    }
  }

  return result;
}
`;
}

function generateIndexFile(): string {
  return `#!/usr/bin/env node
import { createServer } from './server.js';
import { loadConfig } from './config.js';
import { parseArgs } from './cli.js';
import { startStdioTransport, startHttpTransport } from './transport/index.js';

async function main(): Promise<void> {
  const config = loadConfig();
  const cliArgs = parseArgs(process.argv.slice(2));

  // CLI args override config
  const transport = cliArgs.transport || config.transport;
  const port = cliArgs.port || config.port;
  const host = cliArgs.host || config.host;

  const server = createServer(config.name, config.version);

  if (transport === 'http') {
    await startHttpTransport(server, { ...config, port, host });
  } else {
    await startStdioTransport(server);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
`;
}

function generateReadmeFile(
  serverName: string,
  description: string,
  toolCount: number,
  language: 'typescript' | 'python' = 'typescript'
): string {
  if (language === 'python') {
    return `# ${serverName}

${description || 'MCP server generated from OpenAPI specification.'}

## Installation

\`\`\`bash
pip install -e .
\`\`\`

## Usage

### STDIO Transport (default)

\`\`\`bash
python -m src.main
\`\`\`

### HTTP Transport

\`\`\`bash
MCP_TRANSPORT=http python -m src.main
\`\`\`

## Tools

This server provides ${toolCount} tools generated from the OpenAPI specification.

## Configuration

Copy \`.env.example\` to \`.env\` and configure:

\`\`\`bash
cp .env.example .env
\`\`\`

## Development

\`\`\`bash
pip install -e ".[dev]"
pytest
\`\`\`
`;
  }

  return `# ${serverName}

${description || 'MCP server generated from OpenAPI specification.'}

## Installation

\`\`\`bash
npm install
npm run build
\`\`\`

## Usage

### STDIO Transport (default)

\`\`\`bash
npm start
\`\`\`

### HTTP Transport

\`\`\`bash
MCP_TRANSPORT=http npm start
\`\`\`

### Development

\`\`\`bash
npm run dev
\`\`\`

## Tools

This server provides ${toolCount} tools generated from the OpenAPI specification.

## Configuration

Copy \`.env.example\` to \`.env\` and configure:

\`\`\`bash
cp .env.example .env
\`\`\`

## Testing

\`\`\`bash
npm test
\`\`\`
`;
}

function generateUnitTestFile(toolNames: string[]): string {
  const imports = toolNames.map((name) => toCamelCase(name)).join(', ');

  return `import { describe, it, expect } from 'vitest';
import { ${imports} } from '../../src/tools/index.js';

describe('Tools', () => {
${toolNames
  .map(
    (name) => `  describe('${name}', () => {
    it('should return a valid response envelope', async () => {
      const result = await ${toCamelCase(name)}({});
      expect(result).toHaveProperty('ok');
      expect(result).toHaveProperty('meta');
      if (result.ok) {
        expect(result).toHaveProperty('data');
      } else {
        expect(result).toHaveProperty('error');
      }
    });
  });
`
  )
  .join('\n')}});
`;
}

function generateE2ETestFile(): string {
  return `import { describe, it, expect } from 'vitest';
import { createServer } from '../../src/server.js';

describe('MCP Server', () => {
  it('should create a server instance', () => {
    const server = createServer();
    expect(server).toBeDefined();
  });
});
`;
}

function generatePythonMainFile(serverName: string): string {
  return `#!/usr/bin/env python3
"""Main entry point for ${serverName} MCP server."""
import asyncio
import os
from .server import create_server


def main() -> None:
    """Run the MCP server."""
    transport = os.getenv("MCP_TRANSPORT", "stdio")

    server = create_server()

    if transport == "http":
        # HTTP transport would be implemented here
        raise NotImplementedError("HTTP transport not yet implemented")
    else:
        # STDIO transport
        asyncio.run(server.run_stdio())


if __name__ == "__main__":
    main()
`;
}

function generatePythonServerFile(
  tools: { name: string; description: string; inputSchema: object }[],
  serverName: string
): string {
  const toolImports = tools.map((t) => t.name.replace(/-/g, '_')).join(', ');

  return `"""MCP Server implementation."""
from mcp.server import Server
from mcp.types import Tool, TextContent
from .tools import ${toolImports}


def create_server(name: str = "${serverName}") -> Server:
    """Create and configure the MCP server."""
    server = Server(name)

    @server.list_tools()
    async def list_tools() -> list[Tool]:
        return [
${tools
  .map(
    (tool) => `            Tool(
                name="${tool.name.replace(/-/g, '_')}",
                description="${tool.description.replace(/"/g, '\\"')}",
                inputSchema=${JSON.stringify(tool.inputSchema)},
            ),`
  )
  .join('\n')}
        ]

    @server.call_tool()
    async def call_tool(name: str, arguments: dict) -> list[TextContent]:
        import json

${tools
  .map(
    (tool) => `        if name == "${tool.name.replace(/-/g, '_')}":
            result = await ${tool.name.replace(/-/g, '_')}(arguments)
            return [TextContent(type="text", text=json.dumps(result, indent=2))]`
  )
  .join('\n')}

        raise ValueError(f"Unknown tool: {name}")

    return server
`;
}

function generatePythonTypesFile(): string {
  return `"""Type definitions for MCP responses."""
from typing import TypeVar, Generic, Any
from dataclasses import dataclass, field
from datetime import datetime


T = TypeVar("T")


@dataclass
class ResponseMeta:
    """Response metadata."""
    retrieved_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    source: str | None = None
    warnings: list[str] = field(default_factory=list)
    pagination: dict | None = None


@dataclass
class SuccessResponse(Generic[T]):
    """Success response envelope."""
    ok: bool = True
    data: T = None
    meta: ResponseMeta = field(default_factory=ResponseMeta)


@dataclass
class ErrorDetail:
    """Error details."""
    code: str
    message: str
    details: dict[str, Any] = field(default_factory=dict)


@dataclass
class ErrorResponse:
    """Error response envelope."""
    ok: bool = False
    error: ErrorDetail = None
    meta: ResponseMeta = field(default_factory=ResponseMeta)


def success_response(data: T, **meta_kwargs) -> dict:
    """Create a success response."""
    return {
        "ok": True,
        "data": data,
        "meta": {
            "retrieved_at": datetime.utcnow().isoformat(),
            "warnings": [],
            **meta_kwargs,
        },
    }


def error_response(code: str, message: str, details: dict = None) -> dict:
    """Create an error response."""
    return {
        "ok": False,
        "error": {
            "code": code,
            "message": message,
            "details": details or {},
        },
        "meta": {
            "retrieved_at": datetime.utcnow().isoformat(),
        },
    }
`;
}

function generatePythonConfigFile(serverName: string, serverVersion: string, baseUrl: string): string {
  return `"""Configuration management."""
import os
from dataclasses import dataclass


@dataclass
class ServerConfig:
    """Server configuration."""
    name: str = "${serverName}"
    version: str = "${serverVersion}"
    transport: str = "stdio"
    port: int = 3000
    host: str = "127.0.0.1"
    api_base_url: str = "${baseUrl}"
    api_key: str | None = None


def load_config() -> ServerConfig:
    """Load configuration from environment."""
    return ServerConfig(
        name=os.getenv("MCP_SERVER_NAME", "${serverName}"),
        version=os.getenv("MCP_SERVER_VERSION", "${serverVersion}"),
        transport=os.getenv("MCP_TRANSPORT", "stdio"),
        port=int(os.getenv("MCP_PORT", "3000")),
        host=os.getenv("MCP_HOST", "127.0.0.1"),
        api_base_url=os.getenv("API_BASE_URL", "${baseUrl}"),
        api_key=os.getenv("API_KEY"),
    )
`;
}

function generatePythonToolFile(
  tool: { name: string; description: string; inputSchema: object },
  baseUrl: string
): string {
  const funcName = tool.name.replace(/-/g, '_');

  return `"""${tool.description}"""
from ..types import success_response, error_response


async def ${funcName}(args: dict) -> dict:
    """
    ${tool.description}

    Args:
        args: Tool arguments

    Returns:
        Standard response envelope
    """
    try:
        # TODO: Implement API call to ${baseUrl}
        # Example:
        # import httpx
        # async with httpx.AsyncClient() as client:
        #     response = await client.post(
        #         "${baseUrl}/endpoint",
        #         json=args,
        #     )
        #     data = response.json()

        return success_response({"result": args})  # Placeholder

    except Exception as e:
        return error_response(
            "UPSTREAM_ERROR",
            f"Failed to execute ${funcName}",
            {"error": str(e)},
        )
`;
}

function generatePythonTestFile(toolNames: string[]): string {
  return `"""Unit tests for tools."""
import pytest
from src.tools import ${toolNames.join(', ')}


${toolNames
  .map(
    (name) => `@pytest.mark.asyncio
async def test_${name}_returns_valid_envelope():
    """Test ${name} returns valid response envelope."""
    result = await ${name}({})
    assert "ok" in result
    assert "meta" in result
    if result["ok"]:
        assert "data" in result
    else:
        assert "error" in result
`
  )
  .join('\n\n')}
`;
}

// Utility functions
function toCamelCase(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

function toPascalCase(str: string): string {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

export { generateTypeScriptScaffold, generatePythonScaffold };
